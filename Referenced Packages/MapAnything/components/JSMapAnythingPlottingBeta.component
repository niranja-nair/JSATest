<apex:component >
	<script type='text/javascript'>
		function analyzeQuery($plottedQuery, callback)
		{
			//initialize query records
			$plottedQuery.data('records', {});
			
			//if this query is for the visible area only, we need to send some additional map data with the request
			var requestData = { visibleAreaOnly: false, includeMetadata: true, offset: 0 };
			if ($plottedQuery.data('visibleAreaOnly'))
			{
				$.extend(requestData, {
					visibleAreaOnly	: true,
					mapLat			: map.getViewBounds().getCenter().latitude,
					mapLong			: map.getViewBounds().getCenter().longitude,
					mapHeight		: map.getViewBounds().getHeight(),
					mapWidth		: map.getViewBounds().getWidth()
				});
			}
			
			//if this isn't an actual saved query, we need to send query metadata
			if ($plottedQuery.data('id').indexOf('Record-') == 0)
			{
				$.extend(requestData, {
					BaseObjectId		: $plottedQuery.data('BaseObjectId'),
					RecordId			: $plottedQuery.data('RecordId'),
					markerColor			: $plottedQuery.data('markerColor'),
					tooltipFieldsString	: $plottedQuery.data('tooltipFieldsString')
				});
			}
			
			//send request for query analysis
			$.getJSON("/apex/MASavedQueryAJAXResources"+pageSuffix+"?action=analyze_query&SavedQueryId=" + $plottedQuery.data('id') + "&UserId=" + UserId, requestData, function handleResponse (response) {
		        if (response.success)
		        {
		        	//store metadata if it was requested
		        	if (requestData.includeMetadata)
		        	{
			        	//update the plotted query row
			        	$plottedQuery.find('.title').text(response.data.savedQueryName);
	    				$plottedQuery.find('.subtitle').text(response.data.baseObjectLabel);
			        
			        	//store basic info
			        	$plottedQuery.data('BaseObjectId', response.data.BaseObjectId);
			        	$plottedQuery.data('savedQueryName', response.data.savedQueryName);
	                	$plottedQuery.data('baseObjectName', response.data.baseObjectName);
	                	$plottedQuery.data('baseObjectLabel', response.data.baseObjectLabel);
			        	$plottedQuery.data('relatedListCount', response.data.relatedListCount);
			        	$plottedQuery.data('supportsActivities', response.data.supportsActivities);
			        	$plottedQuery.data('supportsChatter', response.data.supportsChatter);
			        	
			        	//store the proximity options
			        	if (response.data.proximityOptions) {
			        		$plottedQuery.data('proximityOptions', {
			        			enabled			: response.data.proximityOptions.enabled == 'true',
			        			hideMarkers		: response.data.proximityOptions.hideMarkers == 'true',
			        			radius			: response.data.proximityOptions.radius,
			        			measurementType	: response.data.proximityOptions.measurementType
			        		});
			        	}
			        	
			        	//store the marker metadata that was returned
			        	$plottedQuery.data('markerMetadata', response.data.markerMetadata);
			        	
			        	//process the color/image assignments (keep track of any images that are used so we can preload them)
			        	$plottedQuery.data('imgIds', []);
			        	var imgIds = $plottedQuery.data('imgIds');
			        	if (response.data.markerMetadata.ColorAssignmentType == 'Static')
			        	{
			        		//this is a static assignment so just record the img id if we have one
			        		if (response.data.markerMetadata.IconColor && response.data.markerMetadata.IconColor.indexOf('image:') == 0)
	                        {
	                            imgIds.push(response.data.markerMetadata.IconColor.split('image:')[1]);
	                        }
			        	}
			        	else if (response.data.markerMetadata.ColorAssignmentType == 'Dynamic, Field')
			        	{
			        		//add each color assignment to our marker metadata and also to the legend
			        		var markerMetadata = $plottedQuery.data('markerMetadata');
			        		markerMetadata.ColorAssignments = {};
			            	$.each((markerMetadata.ColorAssignment || '<Other>~#00FF00').split('~~'), function (index, colorAssignment) {
			            	
			            		//split this color assignment to get the value and color/image
			            		var colorAssignmentParts = colorAssignment.split('~');
			            		
			            		//record the img id for this assignment if we have one
			            		var imgId = '';
		            			if (colorAssignmentParts[1] && colorAssignmentParts[1].indexOf('image:') == 0)
		                        {
		                        	imgId = colorAssignmentParts[1].split('image:')[1];
		                            imgIds.push(imgId);
		                        }
		                        
		                        //start building a new legend row for this assignment
		                        var $newLegendRow = $(
		            				"<tr class='legend-row' style='display: none;'><td><input type='checkbox' class='legend-checkbox' checked='checked' data-value='::AssignmentValue::' /> ::AssignmentValue::</td><td class='visiblemarkers'></td><td class='of'></td><td class='totalmarkers'></td><td class='legend-color' style='background-color: ::AssignmentColor::;'></td></tr>"
		            				.replace(/::AssignmentValue::/g, htmlEncode(colorAssignmentParts[0]))
		            				.replace(/::AssignmentColor::/g, htmlEncode(colorAssignmentParts[1]))
		            			).data('numMarkers', 0);
		            			
		            			//replace the color with an image if needed
		            			if (imgId != '')
		            			{
		            				$newLegendRow.find('.legend-color').addClass('image').html('<img src="/servlet/servlet.FileDownload?file='+imgId+'" style="height: 20px; max-width: 30px;" />');
		            			}
		                        
			            		//add this legend row to the legend
			            		if (colorAssignmentParts[0] == '<Other>')
			            		{
			            			//this color is to be used for values that don't match an option.  store it separately
			            			markerMetadata.IconColorOther = colorAssignmentParts[1];
			            			$plottedQuery.find('table.legend').append($newLegendRow.addClass('other'));
			            		}
			            		else
			            		{
			            			
			            			//add this value/color pair to the assignments
			            			markerMetadata.ColorAssignments[colorAssignmentParts[0]] = colorAssignmentParts[1];
			            			$plottedQuery.find('table.legend').append($newLegendRow);
			            		}
			            		
			            	});
			            	
			            	//show the legend
			            	$plottedQuery.find('.legend').show();
			        	}
			        	
			        	//store the field info that was returned
			        	$plottedQuery.data('addressFields', response.data.addressFields);
			        	$plottedQuery.data('coordinateFields', response.data.coordinateFields);
			        	
			        	//store the tooltip info that was returned
			        	$plottedQuery.data('tooltips', response.data.tooltips);
			        	
			        	//store the method that was used to get the ids (cache or query)
			        	$plottedQuery.data('method', response.data.method);
		        	}
		        	
		        	//store the record ids that were returned
		        	var records = $plottedQuery.data('records');
		        	$.each(response.data.results, function (index, recordId) {
		        		records[recordId] = {
		        			savedQueryId: $plottedQuery.data('id'),
		        			contentKey: $plottedQuery.data('id') + '-' + recordId,
		        			plottedQuery: $plottedQuery,
		        			isProcessed: false,
		        			isGeocoded: false,
		        			isVisible: false
		        		};
		        	});
		        	
		        	//determine if we need to make another callout for more results
		        	if (response.data.results.length >= 25000)
		        	{
		        		//need to get more results.  send a new request with an updated offset and don't request metadata
		        		requestData.offset += response.data.results.length;
		        		requestData.includeMetadata = false;
		        		$.getJSON("/apex/MASavedQueryAJAXResources"+pageSuffix+"?action=analyze_query&SavedQueryId=" + $plottedQuery.data('id') + "&UserId=" + UserId, requestData, handleResponse)
		        		.error(function () {
		        			growlError($('#growl-wrapper'), 'Error Analyzing Query', 3000);
		        			removeQuery($plottedQuery.removeClass('loading').addClass('unloading')); 
		        		});
		        		
		        		//status update
		        		$plottedQuery.find('.status').html('Running query...' + requestData.offset);
		        	}
		        	else
		        	{
			        	//done.  preload each image that this query will be using
	                    imgLoaderCounts[$plottedQuery.data('id')] = 0;
	                    $.each($plottedQuery.data('imgIds'), function (index, imgId) {
	                        var img = new Image();
	                        img.queryId = $plottedQuery.data('id');
	                        img.imgId = imgId;
	                        img.name = '/servlet/servlet.FileDownload?file='+imgId;
	                        img.src = '/servlet/servlet.FileDownload?file='+imgId;
	                        img.onload = imgLoaded;
	                        img.onerror = imgError;
	                        img.onabort = imgError;
	                        
	                        imgLoaderCounts[$plottedQuery.data('id')] = imgLoaderCounts[$plottedQuery.data('id')] + 1;
	                    });
	                    
	                    //set an interval to determine when all of the images have loaded so we can continue processing
		                imgLoaderIntervals[$plottedQuery.data('id')] = setInterval(
		                    function () {
		                        if ((imgLoaderCounts[$plottedQuery.data('id')] || 0) == 0) {
		                            clearInterval(imgLoaderIntervals[$plottedQuery.data('id')]);
		                            try { callback(true, records); } catch (err) { }
		                        }
		                    }, 400
		                );
		            }
		        }
		        else
		        {
		        	$plottedQuery.removeClass('loading').addClass('error').find('.status').text(response.message); 
		        }
		    })
		    .error(function(jqXHR, textStatus, errorThrown) {
		    	$plottedQuery.removeClass('loading').addClass('error').find('.status').text('Unknown Error');
		    });
		}
		
		function processBatch($plottedQuery, recordBatch)
		{
			//start building a data object to send with the request
			var requestData = {
				records: JSON.stringify(recordBatch),
				tooltips: JSON.stringify(
					$.map($plottedQuery.data('tooltips'), function (tooltip, index) { 
						return { 
							FieldName: tooltip.FieldName, 
							RefFieldName: tooltip.RefFieldName 
						}; 
					})
				)
			};
			
			//if this is a record query, we need to send query metadata
			if ($plottedQuery.data('id').indexOf('Record-') == 0)
			{
				$.extend(requestData, {
					BaseObjectId		: $plottedQuery.data('BaseObjectId'),
					RecordId			: $plottedQuery.data('RecordId'),
					markerColor			: $plottedQuery.data('markerColor'),
					tooltipFieldsString	: $plottedQuery.data('tooltipFieldsString')
				});
			}
			
			var records = $plottedQuery.data('records');
			var recordsToGeocode = $plottedQuery.data('recordsToGeocode');
			$.getJSON("/apex/MASavedQueryAJAXResources"+pageSuffix+"?action=process_batch&SavedQueryId=" + $plottedQuery.data('id') + "&UserId=" + UserId, requestData, function (response) {
		        if (response.success)
		        {
		        	var latField = $plottedQuery.data('coordinateFields').Latitude;
		        	var longField = $plottedQuery.data('coordinateFields').Longitude;
		        	var verifiedLatField = $plottedQuery.data('coordinateFields').VerifiedLatitude;
		        	var verifiedLongField = $plottedQuery.data('coordinateFields').VerifiedLongitude;
		        	var addressFields = $plottedQuery.data('addressFields');
		        	
		        	//loop through the response records and extend them with the received data
		        	$.each(response.data.records, function (index, record) {
		        	
		        		//extend the record
		        		$.extend(records[record.Id], {
		        			isProcessed: true,
		        			isGeocoded: false,
		        			isBadAddress: false,
		        			record: record,
		        			latitude: extractValue(record, latField),
		        			longitude: extractValue(record, longField),
		        			verifiedLatitude: extractValue(record, verifiedLatField),
		        			verifiedLongitude: extractValue(record, verifiedLongField),
		        			markerIconText: $plottedQuery.data('markerMetadata').ColorAssignmentType == 'Static' ? '' : 'L',
		        			markerAddress: extractValue(record, addressFields.Street) + "," + extractValue(record, addressFields.City) + " " + extractValue(record, addressFields.State) + "," + extractValue(record, addressFields.Zip) + (extractValue(record, addressFields.Country) == '' ? '' : ','+extractValue(record, addressFields.Country)),
		        			formattedMarkerAddress: extractValue(record, addressFields.Street).replace(/\n\r?/g, '<br />') + "<br />" + extractValue(record, addressFields.City) + " " + extractValue(record, addressFields.State) + "," + extractValue(record, addressFields.Zip) + (extractValue(record, addressFields.Country) == '' ? '' : '<br />'+extractValue(record, addressFields.Country))
		        		});
		        		records[record.Id].markerLatitude = (records[record.Id].verifiedLatitude || records[record.Id].latitude);
		        		records[record.Id].markerLongitude = (records[record.Id].verifiedLongitude || records[record.Id].longitude);
		        		
		        		//determine if this record is already geocoded (make sure that the lat/long is valid).  if it's not, add it to the list to be geocoded
		        		var markerLat = parseFloat(records[record.Id].markerLatitude);
		        		var markerLong = parseFloat(records[record.Id].markerLongitude);
		        		if (!isNaN(markerLat) && !isNaN(markerLong) && markerLat >= -90 && markerLat <= 90 && markerLong >= -180 && markerLong <= 180) {
		        			records[record.Id].isGeocoded = true;
		        		}
		        		else {
		        			recordsToGeocode.push(records[record.Id]);
		        		}
		        	});
		        	
		        	//some records may not be returned due to activity filtering.  remove those records
		        	$.each(recordBatch, function (index, recordId) {
		        		if (!records[recordId].isProcessed) {
		        			delete records[recordId];
		        		}
		        	});
		        }
		        else
		        {
		        }
	    	})
		    .error(function(jqXHR, textStatus, errorThrown) {
		    });
		}
		
		function geocodeRecord(record, callback)
		{
			record.isGeocoded = true;
			var $plottedQuery = record.plottedQuery;
			$plottedQuery.data('numGeocodeRequestsCompleted', $plottedQuery.data('numGeocodeRequestsCompleted') + 1);
		
			var URLParams = "action=GeoCode&geocodetype=MarkerGeoCode&savelatlong=true&savedqueryid=" +record.savedQueryId+ "&recordid=" +record.record.Id;
		    $.getJSON("/apex/MAGeoCodeAJAXResources", URLParams + "&searchtext=" + encodeURIComponent(record.markerAddress), function(response)
		    {
		    	if (response.success)
		    	{
		    		$.extend(record, {
			    		latitude		: response.Latitude,
			    		longitude		: response.Longitude,
			    		markerLatitude	: response.Latitude,
			    		markerLongitude	: response.Longitude
			    	});
			    	
			    	if (!response.RecordUpdate)
			        {
			            Debug("Failed to Update Record: " + response.RecordUpdateError);
			        }
		    	}
		    	else
		    	{
		    		record.isBadAddress = true;
		    	}
		    	
		    	callback(response.success);
		    });
		}
		
		function geocodeMultiple(objectsToGeocode, callback, additionalRequestData)
		{
			//find a parent address field if there is one (need this to know which record to update with the geo data)
			var parentAddressField = '';
			if (additionalRequestData && additionalRequestData.LatitudeField && additionalRequestData.LatitudeField.indexOf('.') != -1) {
				parentAddressField = additionalRequestData.LatitudeField.split('.')[0];
			}
			
			//put a geocoding index on each object so that we can match up the returns
			var geocodeIndex = 1;
			var geocodeRequestObjects = [];
			var objectsToGeocodeMap = {};
			$.each(objectsToGeocode, function (index, obj) {
				geocodeRequestObjects.push({
					geocodeIndex: geocodeIndex,
					searchtext: obj.markerAddress,
					IdToUpdate: obj.record
						? (parentAddressField == '' ? obj.record.Id : obj.record[parentAddressField].Id)
						: null
				});
				objectsToGeocodeMap[geocodeIndex] = obj;
				geocodeIndex++;
			});
			
			var requestData = $.extend(
				(additionalRequestData || {}), 
				{
					action: 'geocodeMultiple',
					serializedObjectsToGeocode: JSON.stringify(geocodeRequestObjects) 
				}
			);
		    $.getJSON("/apex/MAGeoCodeAJAXResources", requestData, function(response)
		    {
		    	var numSuccess = 0;
		    	var numFail = 0;
		    	if (response.success)
		    	{
			    	$.each(response.results, function (index, result) {
			    		var obj = $.extend(objectsToGeocodeMap[result.geocodeIndex], {
			    			isBadAddress	: result.geoData.IsBadAddress,
							latitude		: result.geoData.Latitude,
				    		longitude		: result.geoData.Longitude,
				    		markerLatitude	: result.geoData.Latitude,
				    		markerLongitude	: result.geoData.Longitude			    		
			    		});

			    		if (!obj.isBadAddress) {
							numSuccess++;
			    		}
			    		else {
			    			numFail++;
			    		}
			    	});
			    	
			    	//check for records that couldn't be updated
			    	$.each(response.SaveResults, function (index, saveResult) {
			    		if (!saveResult.success) {
			    			try { Debug('Update Failed: ' + saveResult.errors[0]); } catch (err) { }
			    		}
			    	});  
		    	}
		    	else
		    	{
		    		$.each(objectsToGeocode, function (index, obj) {
			    		obj.isGeocoded = obj.isBadAddress = true;
			    	});
		    		numFail += objectsToGeocode.length;
		    	}
		    	
		    	try { callback(numSuccess, numFail); } catch (err) { }
		    })
		    .error(function () {
		    	$.each(objectsToGeocode, function (index, obj) {
		    		obj.isGeocoded = obj.isBadAddress = true;
		    	});
		    	try { callback(0, objectsToGeocode.length); } catch (err) { }
		    });
		}
		
		function updateMissingAddressContent ($plottedQuery)
		{
			//add a missing addresses section for this query if we need one
    		if ($('[id="MissingAddressesContent #'+$plottedQuery.data('id')+'_MissingAddresses_Header"]').length == 0)
    		{
    			//add a missing addresses section for this query
    			$('#MissingAddressesContent').append(
	    			$('.missingaddresses.template').clone().find('table').html('').closest('.missingaddresses').removeClass('template').wrap('<div/>').parent().html()
	    			.replace(/::SavedQueryId::/g, $plottedQuery.data('id'))
	    			.replace(/::SavedQueryName::/g, $plottedQuery.data('savedQueryName'))
	    		);
    		}
    		
    		//remove any missing addresses for this query
    		$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] table .missingaddress').remove();
    		
    		//loop through the records that are marked as bad addresses
    		$.each($plottedQuery.data('records'), function (index, record) {
    			if (record.isBadAddress) {
    			
		    		//create a missing address for this record
		    		var $newMissingAddress = $(
		    				$('.missingaddresses.template .missingaddress').clone().wrap('<div/>').parent().html()
			    			.replace(/::RecordId::/g, record.record.Id)
			    			.replace(/::Tooltip1::/g, extractTooltipValue($plottedQuery.data('tooltips')[0], record))
			    			.replace(/::MarkerAddress::/g, record.markerAddress)
			    	);
			    	
			    	//add export data.  this data will be sent during an export request
			    	var addressFields = $plottedQuery.data('addressFields');
			    	$newMissingAddress.data('exportData', {
						recordId		: record.record.Id,
						objectType		: $plottedQuery.data('baseObjectLabel'),
						savedQueryName	: $plottedQuery.data('savedQueryName'),
						tooltip1Label	: $plottedQuery.data('tooltips')[0] ? $plottedQuery.data('tooltips')[0].FieldLabel : '',
						tooltip1Value	: extractTooltipValue($plottedQuery.data('tooltips')[0], record),
						street			: extractValue(record, addressFields.Street),
						city			: extractValue(record, addressFields.City),
						state			: extractValue(record, addressFields.State),
						zip				: extractValue(record, addressFields.Zip),
						country			: extractValue(record, addressFields.Country)
					});
					
			    	//append the missing address to the list for this query
		    		$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] table').append($newMissingAddress);
		    	}
    		});
    		
    		//update the missing address count
    		$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] .count').text('('+$('#MissingAddressesContent [id="'+$plottedQuery.data('id')+'_MissingAddresses_Header"] .missingaddress').length+')');
		}
		
		function renderQuery($plottedQuery, renderAs, callback)
		{
			switch (renderAs)
			{
				case 'Markers':
				
			        //get a list of any active prox circles (used to determine if each marker should be made visible)
			        var proxObjects = [];
			        $('#PlottedQueriesTable .layer.proximity').each(function () {
			        	if ($(this).data('proxObject')) {
			        		proxObjects.push($(this).data('proxObject'));
			        	}
			        	if ($(this).data('proxObjects')) {
			        		$.each($(this).data('proxObjects'), function (index, proxObject) {
			        			proxObjects.push(proxObject);
			        		});
			        	}
			        });
			        $('#PlottedQueriesTable .PlottedRowUnit').each(function () {
			        	$.each($(this).data('proximityObjects'), function (index, proxObject) {
			        		proxObjects.push(proxObject);
			        	});
			        });
			        
			        //make sure each prox object has a markers object and clear the markers for this query
			        $.each(proxObjects, function (index, proxObject) {
			        	if (!proxObject.markers) { proxObject.markers = {}; }
			        	proxObject.markers[$plottedQuery.data('id')] = []; 
			        });
				
					//loop through the records
					var markerRendererBatchSize = 100;
					var markerRendererTimeout = 50;
					var markersToRender = [];
	    			$.each($plottedQuery.data('records'), function (index, record) {
	    				if (record.marker && !record.isVisible) {
	    					if (proxObjects.length > 0)
	    					{
	    						var invertProximity = $('#InvertProximityCheckbox').is(':checked');
	    						
	    						//loop through all prox objects to see if this marker falls inside or outside
	    						var markerPixel = map.geoToPixel(record.marker.coordinate);
	    						var isInsideProxObject = false;
	    						$.each(map.getObjectsAt(markerPixel.x, markerPixel.y), function (index, obj) {
	    							if (obj.layerType == 'prox') {
	    								isInsideProxObject = true;
	    								try { obj.markers[$plottedQuery.data('id')].push(record.marker); } catch (err) { console.log('warning: ' + err); }
	    							}
	    						});
	    						
	    						//determine if we should continue based on whether or not prox visibility has been inverted or this query has prox enabled
	    						var queryProximityEnabled = ($plottedQuery.data('proximityOptions') && $plottedQuery.data('proximityOptions').enabled);
	    						if (((invertProximity && isInsideProxObject) || (!invertProximity && !isInsideProxObject)) && !queryProximityEnabled)
	    						{
	    							//we should not plot this marker so continue to the next one
	    							return;
	    						}
	    					}
	    					
	    					//if we made it this far, then we should render this marker
    						record.isVisible = true;
		                	markersToRender.push(record.marker);
		                	
		                	//update the legend visible marker counter if needed
		                	if (record.legendRow) {
		                		var visibleMarkersText = record.legendRow.find('.visiblemarkers').text();
		                		record.legendRow.find('.visiblemarkers').text((parseInt(visibleMarkersText) || 0) + 1);
		                	}
	    				}
	    				
	    				if (markersToRender.length + map.objects.length > 10000) { return false; }
	    			});
	    			
	    			//check proximity options before rendering
	    			var proximityOptions = ($plottedQuery.data('proximityOptions') || {});
	    			var proximityObjects = $plottedQuery.data('proximityObjects');
					
					//render markers in batches using a timeout
					$plottedQuery.data(
						'markerRendererTimeout', 
						setTimeout(function doBatch() {
							
							//grab a batch of markers that aren't already visible
							var markers = [];
							while (markersToRender.length > 0 && markers.length < markerRendererBatchSize)
							{
								var markerToPush = markersToRender.pop();
								
								if (!proximityOptions.enabled || !proximityOptions.hideMarkers) {
									markers.push(markerToPush);
								}
								else {
									markerToPush.record.isVisible = false;
								}
								
								//if this query has proximity circles enabled, add a circle for this marker
								if (proximityOptions.enabled && proximityObjects.length < 200) {
									try {
										proximityObjects.push(
											new nokia.maps.map.Circle(
										       markerToPush.coordinate,
										       proximityOptions.radius * unitFactors[proximityOptions.measurementType]['METERS'],
										       {
											       layerType: 'prox',
											       color: "#823f",
											       fillColor: "#2387",
											       width: 2
										       }
											)
										);
									}
									catch (err) { }
								}
							}
			    			
			    			//add the markers to the map
							map.objects.addAll(markers);
			    			
			    			//should we keep rendering?
			    			if (markersToRender.length == 0)
			    			{
			    				//no, so hide markers based on unchecked values in the legend (if we have any)
			    				$plottedQuery.find('.legend-checkbox').not(':checked').change();
			    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
			    				
			    				//render proximity circles if there are any
			    				if (proximityObjects.length > 0) {
			    					map.objects.addAll(proximityObjects);
			    					ChangeVisibilityWhenCircleIsAdded();
			    				}
			    				
			    				//update query info
				                updateQueryInfo($plottedQuery);
			    				
			    				//done, so fire the callback
			    				try { callback(); } catch (err) { }
			    			}
			    			else
			    			{
			    				//yes, so set a new timeout to process the next batch
			    				setTimeout(doBatch, markerRendererTimeout);
			    			}
							
						}, markerRendererTimeout)
					);
					break;
					
				case 'Heatmap':
					
					//remove the existing heat map if there is one
	                if ($plottedQuery.data('heatmapProvider'))
	                {
	                	map.overlays.remove($plottedQuery.data('heatmapProvider'));
	                	$plottedQuery.data('heatmapProvider', null);
	                }
	                
					var heatmapProvider = new nokia.maps.heatmap.Overlay({
	                    max: 20,
	                    opacity: 1,
	                    type: "density",
	                    coarseness: 2,
	                    sampleDepth: 4,
	                    colors: {
						    interpolate : true,
						    stops       : {
						        0       : '#00B',
						        0.2     : '#0b0',
						        0.5     : '#ff0',
						        0.7     : '#f00'
						    }
						}
	                });
	
					var heatMapDataPoints = [];
					$.each($plottedQuery.data('records'), function (index, record) {
	    				if (record.markerLatitude != '' && record.markerLongitude != '') {
	    					heatMapDataPoints.push({
	    						value: 0,
			                    latitude: record.markerLatitude,
			                    longitude: record.markerLongitude
	    					});
	    				}
	    			});
					
	                heatmapProvider.addData(heatMapDataPoints);
	                map.overlays.add(heatmapProvider);
	                
	                $plottedQuery.data({ heatmapProvider: heatmapProvider, numHeatmapDataPoints: heatMapDataPoints.length });
	                $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
	                
	                //update query info
				    updateQueryInfo($plottedQuery);
	                
	                //done so fire callback
	                try { callback(); } catch (err) { }
					break;
					
				case 'Cluster':
				    var clusterProvider = new nokia.maps.clustering.ClusterProvider(map, {
				        eps: 16,
				        minPts: 1,
				        dataPoints: [],
				        theme: new nokia.maps.clustering.MarkerTheme()
				    });
				    
				    var clusterDataPoints = [];
				    $.each($plottedQuery.data('records'), function (index, record) {
	    				if (record.markerLatitude != '' && record.markerLongitude != '') {
	    					clusterDataPoints.push({
			                    latitude: record.markerLatitude,
			                    longitude: record.markerLongitude
	    					});
	    				}
	    				
	    				if (clusterDataPoints.length > 12000) { return false; }
	    			});
				    
				    clusterProvider.addAll(clusterDataPoints);
				    clusterProvider.cluster();
				    
				    $plottedQuery.data({ clusterProvider: clusterProvider, numClusterDataPoints: clusterDataPoints.length });
				    $plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').addClass('on');
				    
				    //update query info
				    updateQueryInfo($plottedQuery);
				    
				    //done so fire callback
				    try { callback(); } catch (err) { }
					break;
			}
		}
		
		function unrenderQuery($plottedQuery, renderAs, callback)
		{
			switch (renderAs)
			{
				case 'Markers':
				
					var markerUnrendererBatchSize = 120;
					var markerUnrendererTimeout = 100;
					
					//remove any query based prox circles
					var proximityObjects = $plottedQuery.data('proximityObjects');
					map.objects.removeAll(proximityObjects);
					$plottedQuery.data('proximityObjects', []);
					
					//unrender markers in batches using a timeout
					$plottedQuery.data(
						'markerUnrendererTimeout', 
						setTimeout(function doBatch() {
						
							//remove markers
							var markers = [];
				   			$.each(($plottedQuery.data('records') || []), function (index, record) {
				   				if (record.marker && record.isVisible) {
				   					record.isVisible = false;
				   					markers.push(record.marker);
				   					
				   					//try to remove any tooltips associated with this marker
				   					if (record.marker.infoBubbleHandle) {
				   						try {
				   							InfoBubbles.removeBubble(record.marker.infoBubbleHandle);
				   						}
				   						catch (err) { }
				   					}
				   				}
				   				
				   				if (markers.length > markerUnrendererBatchSize) { return false; }
				   			});
				   			map.objects.removeAll(markers);
				   			
				   			//should we keep unrendering?
			    			if (markers.length == 0)
			    			{
			    				//no, so fire the callback
			    				$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
			    				if (proximityObjects.length > 0) {
			    					ChangeVisibilityWhenCircleIsAdded();
			    				}
			    				updateQueryInfo($plottedQuery);
			    				try { callback(); } catch (err) { }
			    			}
			    			else
			    			{
			    				//yes, so set a new timeout to process the next batch
			    				setTimeout(doBatch, markerUnrendererTimeout);
			    			}
			   			
			   			}, markerUnrendererTimeout)
			   		);
			   		
		   			//set legend row visible markers to 0
		   			$plottedQuery.find('.legend-row .visiblemarkers').text('0');
		   			
					break;
				case 'Heatmap':
				
					//remove heat map if it exists
					if ($plottedQuery.data('heatmapProvider')) {
						map.overlays.remove($plottedQuery.data('heatmapProvider'));
					}
					
					//fire the callback
					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
					updateQueryInfo($plottedQuery);
					try { callback(); } catch (err) { }
					
					break;
				case 'Cluster':
				
					//remove cluster if it exists
					if ($plottedQuery.data('clusterProvider')) {
						$plottedQuery.data('clusterProvider').destroy();
					}
					
					//fire the callback
					$plottedQuery.find('.renderButtons-button[data-renderAs='+renderAs+']').removeClass('on');
					updateQueryInfo($plottedQuery);
					try { callback(); } catch (err) { }
					
					break;
			}
		}
		
		function updateQueryInfo($plottedQuery)
		{
			var infoHTML = '';
			var queryData = $plottedQuery.data();
			
			//general data point info
			$plottedQuery.find('.status').html('Data Points: ' + $plottedQuery.data('numRecords') + ($plottedQuery.data('method') == 'cache' ? ' (from cache)' : ''));
			
			//geocode info
			if (queryData.numGeocodeRequestsNeeded > 0) {
				infoHTML += "<div>"+queryData.numGeocodeRequestsNeeded+" geocodes completed.  <span class='geocode link'>"+queryData.numFailedGeocodes+" bad address(es)</span>.</div>";
			}
			
			//marker info
			if ($plottedQuery.find('.renderButtons-button.markers').is('.on')) {
				var visibleMarkerCount = 0;
				$.each(queryData.records, function (recordId, record) {
					if (record.isVisible) {
						visibleMarkerCount++;
					}
				});
				infoHTML += "<div>"+queryData.numMarkers+" markers created, "+visibleMarkerCount+" visible.</div>";
			}
			
			//heatmap info
			if ($plottedQuery.find('.renderButtons-button.heatmap').is('.on')) {
				infoHTML += "<div>"+$plottedQuery.data('numHeatmapDataPoints')+" heatmap data points.</div>";
			}
			
			//cluster info
			if ($plottedQuery.find('.renderButtons-button.cluster').is('.on')) {
				infoHTML += "<div>"+$plottedQuery.data('numClusterDataPoints')+" cluster data points.</div>";
			}
			
			$plottedQuery.find('.plottinginfo-wrapper .info').html(infoHTML);
		}
		
		function removeQuery($plottedQuery)
		{
			//unrender everything
			unrenderQuery($plottedQuery, 'Heatmap', function () {
				unrenderQuery($plottedQuery, 'Cluster', function () {
					unrenderQuery($plottedQuery, 'Markers', function () {
						
						//remove plotted query
						$plottedQuery.remove();
						UpdateAddToCampaignButton();
							
					});					
				});
			});
		}
		
		function CreateMarkerFromRecord(record)
		{
			//get the value of the first tooltip (it will be used as the title for this marker)
            var tooltip1Value = 'Unknown';
            var tooltip1Metadata = record.plottedQuery.data('tooltips')[0];
            if (tooltip1Metadata)
            {
            	tooltip1Value = extractTooltipValue(tooltip1Metadata, record);
            }
            
            //get the color/image for this marker
            var markerMetadata = record.plottedQuery.data('markerMetadata');
            var markerColor = '#000000';
            if (markerMetadata.ColorAssignmentType == 'Static')
            {
            	markerColor = markerMetadata.IconColor;
            }
            else if (markerMetadata.ColorAssignmentType == 'Dynamic, Field')
            {
            	var picklistValue = extractValue(record.record, markerMetadata.PicklistField);
            	if (markerMetadata.ColorAssignments[picklistValue])
            	{
            		//set the marker color
            		markerColor = markerMetadata.ColorAssignments[picklistValue];
            		
            		//update the legend marker count
            		var $legendRow = record.plottedQuery.find('.legend-checkbox[data-value="'+picklistValue+'"]').closest('.legend-row');
            		$legendRow.data('numMarkers', $legendRow.data('numMarkers') + 1);
            		
            		//store the legend row with the record for easy access later
            		record.legendRow = $legendRow;
            	}
            	else if (markerMetadata.IconColorOther)
            	{
            		//set the marker color as the value defined for <Other>
            		markerColor = markerMetadata.IconColorOther;
            		
            		//update the legend marker count for <Other>
            		var $legendRow = record.plottedQuery.find('.legend-row.other');
            		$legendRow.data('numMarkers', $legendRow.data('numMarkers') + 1);
            		
            		//store the legend row with the record for easy access later
            		record.legendRow = $legendRow;
            	}
            	else
            	{
            		//this should never happen, but if we don't have a color for this value and we don't have a color for <Other>, then just make the marker black
            		markerColor = '#000000';
            	}
            }
		
			//create marker options
			var MarkerCoordinate = new nokia.maps.geo.Coordinate(parseFloat(record.markerLatitude), parseFloat(record.markerLongitude));         
		    var markerOptions = {
		        title: tooltip1Value,
		        visibility: true,
		        brush: markerColor,
		        Ignore: false, 
		        SavedQryId: record.savedQueryId,
		        Lat: record.markerLatitude,
		        Long: record.markerLongitude,
		        PicklistFieldValue: null,
		        record: record,
		        text: record.markerIconText,
		        eventListener: {
		            "click": [marker_Click, false, null],
		            "tap": [marker_Click, false, null]
		        }
		    };
		    
		    //create either an image marker or a standard marker depending on the markerColor value
		    if (markerColor && markerColor.indexOf('image:') == 0)
			{
			    delete markerOptions.brush;
			    
			    if (imgLoaderDimensions[markerColor.split('image:')[1]]) {
			        $.extend(markerOptions, {
			            icon: '/servlet/servlet.FileDownload?file=' + markerColor.split('image:')[1],
			            anchor: new nokia.maps.util.Point(
			                Math.floor(imgLoaderDimensions[markerColor.split('image:')[1]].width / 2), 
			                imgLoaderDimensions[markerColor.split('image:')[1]].height
			            )
			        });
			        return new nokia.maps.map.Marker(MarkerCoordinate, markerOptions);
			    }
			}
			return new nokia.maps.map.StandardMarker(MarkerCoordinate, markerOptions);
		}
		
		function marker_Click()
        {
        	var marker = this;
            var record = this.record;
            var queryMetadata = record.plottedQuery.data();
            
            //if the map is currently waiting for a route optimization click, we need to handle that instead of creating a tooltip
            if (currentState == 'Optimize Directions Step 1') 
            {
            	//find the matching marker on the directions tab and move it to the top
            	$('#sortable').children().each(function () {
            		if ($(this).attr('waypointtitle') == marker.title) {
            			$(this).prependTo($('#sortable'));
            			$currentStateGrowl = growlWarning($currentStateGrowl, 'Pick an ending location by clicking a marker, using the directions tab, or use your <span style="color: blue; cursor: pointer;" onclick="optimizeRoute_UseHome();">home location<span>', false);
            			currentState = 'Optimize Directions Step 2';
            			return false;
            		}
            	});
            	return;
            }
            else if (currentState == 'Optimize Directions Step 2')
            {
            	//find the matching marker on the directions tab and move it to the top
            	$('#sortable').children().each(function () {
            		if ($(this).attr('waypointtitle') == marker.title) {
            			$(this).appendTo($('#sortable'));
            			$currentStateGrowl = growlLoading($currentStateGrowl, 'Optimizing route...', false);
            			currentState = 'Optimize Directions Step 3';
            			return false;
            		}
            	});
            	optimizeRoute();
            	return;
            }
            
            //start building tooltip content from template
            var $tooltipContent = $('#tooltip-content-template').clone().attr('id', 'tooltip-content');
            
            //show related list tab if needed
            if (queryMetadata.relatedListCount > 0) { 
                $tooltipContent.find('#tab-relatedlist').show(); 
            }
            
            //show picklist field info if needed 
            if (queryMetadata.markerMetadata.ColorAssignmentType == 'Dynamic, Field') { 
                $tooltipContent.find('.picklistinfo').show(); 
            }
            
            //show activity buttons if needed
            if (queryMetadata.supportsActivities) {
                $tooltipContent.find('.activitybuttons').show();
            }
            
            //add tooltips
            var $tooltips = $tooltipContent.find('.tooltips > table');
            var tooltip1Value = 'Tooltip 1';
            $.each(queryMetadata.tooltips, function (index, tooltip) 
            {
       			//if this is the first tooltip, keep track of the value for use later.  otherwise, append it to the tooltips
            	if (index == 0)
            	{
            		tooltip1Value = extractTooltipValue(tooltip, record);
            	}
            	else
            	{
            		//create a new tooltip row
            		var $newTooltip = $("<tr class='tooltip-row'><td class='label'><b>"+tooltip.FieldLabel+"</b></td><td class='value'>"+extractTooltipValue(tooltip, record)+"</td><td class='tooltip-loader'><img class='saving' src=\"{!URLFOR($Resource.MapAnything, '/images/chatterstatus-loader.gif')}\" /><img class='error' src=\"{!URLFOR($Resource.MapAnything, 'images/x-22.png')}\" title='Unable to save' /></td></tr>");
            		
            		//make this tooltip editable if needed
            		if (tooltip.Accessible && tooltip.Updateable && displayTypeMetadata[tooltip.DisplayType]) {
            			$newTooltip.find('td.value').addClass('editable');
            		}
            		
            		//if this tooltip row is for a textarea, allow wrapping
            		if (tooltip.DisplayType == 'TEXTAREA') {
            			$newTooltip.find('td.label').css('vertical-align', 'top');
            			$newTooltip.find('td.value').css('white-space', 'normal');
            		}
            		
            		//append this new row to the tooltips table
            		$newTooltip.appendTo($tooltips).data('tooltip', tooltip);
            	}
            });
            
            //build the url for the standard email page for this record (for use with the email tooltip action)
            var EmailURL = "p2_lkid=" + record.record.Id + "&rtype=" + record.record.Id.substring(0,3) + "&retURL=%2F" + record.record.Id;
            if(record.record.Id.substring(0,3) === "001")
            {
                EmailURL = "p3_lkid=" + record.record.Id + "&retURL=%2F" + record.record.Id;
            }               
            
            //create info bubble
            marker.infoBubbleHandle = InfoBubbles.addBubble(
                $tooltipContent.wrap('<div></div>').show().parent().html()
                    .replace(/::ContentKey::/g, record.contentKey)
                    .replace(/::Id::/g, record.record.Id)
                    .replace(/::Name::/g, tooltip1Value)
                    .replace(/::Address::/g, record.markerAddress)
                    .replace(/::PicklistFieldLabel::/g, 'PicklistFieldLabel')
                    .replace(/::PicklistFieldValue::/g, 'PicklistFieldValue')
                    .replace(/::EmailURL::/g, EmailURL),
                new nokia.maps.geo.Coordinate(parseFloat(marker.Lat), parseFloat(marker.Long))
            );
            
            //find the tooltip that is now attached to the dom
            $tooltipContent = $('#tooltip-content');
                            
            //init tabs
            $tooltipContent.find('.tabs').tabs();
            
            //init tooltip rows
            $tooltipContent.find('.tooltip-row').each(function () {
            	$(this).data('saveTimeouts', []);
            });
            
            //handle clicking to edit tooltips
            $tooltipContent.on('click', '.tooltip-row td.value.editable', function () {
            
            	//close any existing picklist fields by clicking the html element
            	$('html').click();
            
            	var $tooltipRow = $(this).closest('.tooltip-row');
            	var tooltipMetadata = queryMetadata.tooltips[$tooltipRow.index() + 1];
            	var $valueCell = $(this).removeClass('editable').addClass('editing');
            	var fieldValue = extractValue(record.record, tooltipMetadata.ActualFieldName);
            	var editType = displayTypeMetadata[tooltipMetadata.DisplayType] ? displayTypeMetadata[tooltipMetadata.DisplayType].editType : '';
            	var renderType = displayTypeMetadata[tooltipMetadata.DisplayType] ? displayTypeMetadata[tooltipMetadata.DisplayType].renderType : '';
            	
            	switch (editType)
            	{
            		case 'string':
            		
	            		$valueCell.html("<input type='text' value='"+fieldValue+"' />").find('input').data('originalValue', fieldValue+'').focus().blur(function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
            			break;
            			
            		case 'number':
            	
	            		$valueCell.html("<input type='text' value='"+fieldValue+"' />").find('input').data('originalValue', fieldValue+'').focus().blur(function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
            	
            		case 'textarea':
            		
	            		$valueCell.html($("<textarea />").val($valueCell.text()).width($valueCell.width()+'px')).find('textarea').data('originalValue', fieldValue+'').focus().select().blur(function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
            		
            		case 'picklist':
            		
	            		var $picklistOptions = $('<select class="combobox" />');
	            		$.each(tooltipMetadata.PicklistOptions, function (index, option) {
	            			$picklistOptions.append($('<option />').attr('value', option.value).text(option.label));
	            		});
	            		$picklistOptions.val($valueCell.text());
	            		
	            		$valueCell.html($picklistOptions).find('.combobox').combobox().next().click(function () {return false;}).find('input').data('originalValue', fieldValue+'').focus().select();
	            		
	            		
	            		$('html').one('click', function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
	            		
	            	case 'multipicklist':
	            		
	            		var $picklistOptions = $('<select class="multiselect" />');
                        $.each(tooltipMetadata.PicklistOptions, function (index, option) {
							$picklistOptions.append($('<option />').attr('value', option.value).text(option.label).attr('checked', (';'+fieldValue+';').indexOf(option.value) != -1));
                        });
                        
                        $valueCell.html($picklistOptions).find('.multiselect').multiselect({
                            noneSelectedText: 'Click here to select options',
                            selectedList: 2,
                            close: function () {
                            	$('html').click();
                            }
                        }).multiselectfilter().multiselect('uncheckAll').multiselect('widget').click(function (e) { e.stopPropagation(); });
                        
                        $('html').one('click', function () {
                        
                        	//save
                       		$picklistOptions.data('newValue', $picklistOptions.multiselect('getChecked').map(function () {
                       			return this.value;
                       		}).get().join(';')).change();
                        
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
            	
            		case 'boolean':
            		
	            		$valueCell.html($("<input type='checkbox' />").attr('checked', $valueCell.text().toLowerCase() == 'true')).find('input').click(function (e) { e.stopPropagation();}).data('originalValue', fieldValue).focus();
	            		
	            		$('html').one('click', function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
	            		
	            	case 'date':
	            	
	            		$valueCell.html($("<input type='text' class='date' />").val($valueCell.text())).find('input').datepicker().focus().click(function (e) {e.stopPropagation();});
	            		
	            		$('html').one('click', function () {
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		
	            		
	            		break;
            	
            		case 'reference':
            		
	            		var $lookup = $('<input type="text" class="autocomplete" />');
	            		$valueCell.html($lookup).find('input').click(function (e) {e.stopPropagation();}).focus().data('originalValue', fieldValue);
	            		
	            		$lookup.autocomplete({
	            			focus: function (event, ui) {
	            				$lookup.val(ui.item.label);
	            				return false;
	            			},
	                		select: function (event, ui) {
	                			$lookup.val(ui.item.label).data('selectedItem', ui.item);
	                			event.stopPropagation();
	                			return false;
	                		},
	                		search: function () {
	                			$lookup.addClass('searching');
	                		},
	                		source: function(request, response) {
						        $.ajax({
			           				url: '/apex/MATooltipAJAXResources?action=get_lookup_options',
							        type: 'POST',
							        dataType: 'JSON',
							        data: {
							        	baseObject: tooltipMetadata.BaseObject,
							        	fieldName: tooltipMetadata.ActualFieldName,
							        	term: request.term
							        },
							        success: function (successResponse)
							        {
							            if (!successResponse.success)
							            {
							            	response([]);
							            	return;
							            }
							            
							            response(successResponse.lookupOptions);
							        },
							        error: function () 
							        {
							        	response([]);
							        },
							        complete: function ()
							        {
							        	$lookup.removeClass('searching');
							        }
			           			});
						    }
	                	});
	                	
	                	$('html').one('click', function () {
	                		var $inputField = $valueCell.find('input');
	                		if ($inputField.data('selectedItem') && $inputField.data('selectedItem').value != $inputField.data('originalValue')) {
	                			$inputField.change();
	                		}
	                	
	            			$valueCell.removeClass('editing').addClass('editable');
	            			if (renderType == 'html') {
			            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
			            	}
			            	else {
			            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
			            	}
	            		});
	            		break;
	            		
	            	default:

	            		//no matching type so do nothing
	            		$valueCell.removeClass('editing').addClass('editable');
	            		return;
	            }
            	
            	//handle pressing tab or enter on an input
            	$valueCell.find('input, textarea').keydown(function (e) {
            		if (e.keyCode == 9) {
            		
            			//find the next element that we want to move focus to by moving forward or backward through the tooltip rows and looking for an editable value
            			var $nextTooltipRow = $(this).closest('.tooltip-row');
            			var $nextElement;
            			while ($nextTooltipRow.length > 0)
            			{
            				$nextTooltipRow = e.shiftKey ? $nextTooltipRow.prev() : $nextTooltipRow.next();
	            			$nextElement = $nextTooltipRow.find('td.value.editable');
	            			if ($nextElement.length > 0) {
	            				break;
	            			}
            			}
            			
            			//fire the change event if the user has changed the value
            			var inputValue = $(this).is('[type="checkbox"]') ? $(this).is(':checked') : $(this).val();
            			if ($(this).data('originalValue') != inputValue) {
            				$(this).change();
            			}
            			
            			//remove focus from this element and click the next one
            			$(this).blur();
            			$('html').click();
            			$nextElement.click();
            			
            			//cancel the default behavior
            			return false;
            		}
            		else if (e.keyCode == 32 && $(this).is('[type="checkbox"]')) {
            			$(this).attr('checked', !$(this).is(':checked'));
            			return false;
            		}
            	});
            	$valueCell.find('input, textarea').keypress(function (e) {
            		if (e.keyCode == 13) {
            		
            			//fire the change event if the user has changed the value
            			var inputValue = $(this).is('[type="checkbox"]') ? $(this).is(':checked') : $(this).val();
            			if ($(this).data('originalValue') != inputValue) {
            				$(this).change();
            			}
            			
            			//remove focus from this element
            			$(this).blur();
            			$('html').click();
            		}
            	});
            	
            	return false;
            	
            });
            
            //handle actually editing tooltips
            $tooltipContent.on('change', '.tooltip-row td.value.editing input, .tooltip-row td.value.editing textarea, .tooltip-row td.value.editing select', function () {

				//gather some basic info about the input field, the tooltip row, and the metadata we have for this tooltip
            	var $inputField = $(this);
            	var $tooltipRow = $inputField.closest('.tooltip-row').addClass('saving').removeClass('error');
            	var tooltipMetadata = queryMetadata.tooltips[$tooltipRow.index() + 1];
            	
            	//figure out the current value of this field based on the type
            	var inputValue = '';
            	var inputValueName = '';
            	if ($inputField.is('[type="checkbox"]'))
            	{
            		 inputValue = $inputField.is(':checked');
            	}
            	else if ($inputField.is('.autocomplete'))
            	{
            		try {
            			inputValue = $inputField.data('selectedItem').value;
            			inputValueName = $inputField.data('selectedItem').label;
            			
            			//remove the selected item to avoid future searching from being considered a valid change
            			$inputField.data('selectedItem', null);
            		}
            		catch (err) 
            		{
            			//this failure means that the value has not yet been selected and this is part of the search function.  do nothing in this case
            			$tooltipRow.removeClass('saving');
            			return false;
            		}
            	}
            	else if ($inputField.is('.multiselect'))
            	{
            		//for a multiselect, a single selection shouldn't trigger an update so wait until we have a new value (assigned by the html click handler for this type)
            		if (!$inputField.data('newValue')) {
            			$tooltipRow.removeClass('saving');
            			return false;
            		}
            		else {
            			inputValue = $inputField.data('newValue');
            			$inputField.data('newValue', null);
            		}
            	}
            	else
            	{
            		inputValue = $inputField.val();
            	}
            	
            	//clear any existing save timeouts for this field
            	var saveTimeouts = $tooltipRow.data('saveTimeouts');
            	$.each(saveTimeouts, function (index, saveTimeout) {
            	
            		try {
            			clearTimeout(saveTimeout);
            			while ($.inArray(saveTimeout, saveTimeouts) != -1)
			        	{
			        		saveTimeouts.splice($.inArray(saveTimeout, saveTimeouts));
			        	}
	            	}
	            	catch (err) { }
            	
            	});
            	
            	//set a timeout to save this field
            	var saveTimeout = setTimeout(function () {
            			
           			$.ajax({
           				url: '/apex/MATooltipAJAXResources?action=save_tooltip',
				        type: 'POST',
				        dataType: 'JSON',
				        data: {
				        	recordId: record.record.Id,
				        	fieldName: tooltipMetadata.ActualFieldName,
				        	newValue: inputValue
				        },
				        success: function (response)
				        {
				            if (!response.success)
				            {
				            	$tooltipRow.addClass('error').find('img.error').attr('title', response.error);
				            	return;
				            }
				            
				            //update the underlying record (and the name field of the related object if this is a reference field)
				            updateValue(record.record, tooltipMetadata.ActualFieldName, extractValue(response.updatedRecord, tooltipMetadata.FieldName));
				            if (inputValueName != '')
				            {
				            	updateValue(record.record, tooltipMetadata.FieldName, inputValueName);
				            }
				            
				            //update the displayed tooltip if we are no longer in edit mode
				            if (!$tooltipRow.find('td.value').is('.editing'))
				            {
				            	if (displayTypeMetadata[tooltipMetadata.DisplayType].renderType == 'html') {
				            		$tooltipRow.find('td.value').html(extractTooltipValue(tooltipMetadata, record));
				            	}
				            	else {
				            		$tooltipRow.find('td.value').text(extractTooltipValue(tooltipMetadata, record));
				            	}
				            }
				        },
				        error: function (response) 
				        {
				        	$tooltipRow.addClass('error').find('img.error').attr('title', 'Unable to save');
				        },
				        complete: function ()
				        {
				        	//remove this timeout from the array of timeouts for this tooltip
				        	while ($.inArray(saveTimeout, saveTimeouts) != -1)
				        	{
				        		saveTimeouts.splice($.inArray(saveTimeout, saveTimeouts));
				        	}
				        	
				        	//if this was the last save timeout for this tooltip then we are no longer saving so remove the saving class
				        	if (saveTimeouts.length == 0) {
				        		$tooltipRow.removeClass('saving');
				        	}
				        }
           			});
           			
           		}, 1000);
           		
           		//store the timeout so it can be cleared later if needed
           		$tooltipRow.data('saveTimeouts').push(saveTimeout);
            	
            });
            
            //build actions layout using the button set settings
            if (!userSettings.ButtonSetSettings)
            {
            }
            else if (!userSettings.ButtonSetSettings.tooltipLayout)
            {
            }
            else
            {
				var tooltipLayout = userSettings.ButtonSetSettings.tooltipLayout;
				var $tooltipLayout = $tooltipContent.find('.layout-tooltip');
				$.each(tooltipLayout, function (sectionIndex, section) {
				
					//add this section
					var $section = $('#templates .buttonset-section').clone().appendTo($tooltipLayout);
					$section.find('.buttonset-section-header').text(section.Label);
					
					//loop over each column in this section
					$.each(section.Columns, function (columnIndex, column) {
						
						//loop over each button in this column
						var $column = $section.find('.buttoncolumn').eq(columnIndex);
						$.each(column, function (buttonIndex, button) {
						
							console.log(button);
							
							//add this button
							var $button = $('<div class="actionbutton" />').attr('data-type', button.Type).text(button.Label).appendTo($column);
							
							//find the definition of this button in the action framework
							var buttonDefinition = {};
							$.each(MAActionFramework.availableButtons, function (index, currentButtonDefinition) {
								if (button.Type == currentButtonDefinition.Type && button.Label == currentButtonDefinition.Label) {
									$.extend(buttonDefinition, currentButtonDefinition);
								}
							});
							
							//validate that this button meets visibility requirements.  if it doesn't then disable it
							$.each(buttonDefinition.Requirements, function (index, requirement) {
								if (requirement == 'ActivitySupport' && !queryMetadata.supportsActivities) {
									$button.addClass('disabled'); return false;
								}
								else if (requirement == 'VerifiedLocationSupport' && !(queryMetadata.coordinateFields.VerifiedLatitude && queryMetadata.coordinateFields.VerifiedLongitude)) {
									$button.addClass('disabled'); return false;
								}
								else if (requirement == 'ContactOrLead' && $.inArray(record.record.Id.substring(0, 3), ['003', '00Q']) == -1) {
									$button.addClass('disabled'); return false;
								}
							});
						
						});
						
					});
				});
			}
            
            //show chatter tab if needed
            if (queryMetadata.supportsChatter) {
                $tooltipContent.find('#tab-chatter').show().find('a').data('recordId', record.record.Id).data('contentKey', record.contentKey).data('loaded', false).click(function () {
                    if (!$(this).data('loaded')) 
                    {
                        //mark as loaded so we don't load again
                        $(this).data('loaded', true);
                        
                        //load chatter integration
                        $(this).closest('#tooltip-content').find('#pane-chatter-'+$(this).data('contentKey')).append("<iframe src='/apex/ChatterFeed?entityId="+$(this).data('recordId')+"' style='width: 100%; height: 300px; border: none;'></iframe>");
                    }
                });
            }
            
            //load related list integration
            if (queryMetadata.relatedListCount > 0)
            {
                $("#ajax-" + record.contentKey)
                    .html('Loading')
                    .load('MAPopupRelatedListInformation',"parentid=" + record.record.Id + '&sqid=' + queryMetadata.id );  
            }
            
            //show/hide action buttons based on permissions
            if (userSettings.EnabledActionButtons) 
            {
            	$tooltipContent.find('.actionbutton').hide();
            	$.each(userSettings.EnabledActionButtons, function (index, buttonLabel) {
            		$tooltipContent.find('.actionbutton[data-label="'+buttonLabel+'"]').show();
            	});
            }
            
            //temporary
            $tooltipContent.find('.layout-tooltip .actionbutton').show();
            
            //hide location verification button if this base object does not support it
            if (!(queryMetadata.coordinateFields.VerifiedLatitude && queryMetadata.coordinateFields.VerifiedLongitude))
            {
            	$('#SetVerifiedLocation-' + record.contentKey).hide();
            }
            
            //hide add to campaign button if this is not a contact or lead
            if ($.inArray(record.record.Id.substring(0, 3), ['003', '00Q']) == -1)
            {
            	$('#AddToCampaign-' + record.contentKey).hide();
            }
            
            //handle clicking an action button
            $('.actionbutton').click(function () {
            	var $button = $(this);
            	if ($button.is('[data-type="StandardButton"]')) {
            		$.each(MAActionFramework.availableButtons, function (index, button) {
            			if (button.Type == 'StandardButton' && button.Label == $button.text()) {
            				button.ActionValue.call(this, {
			            		record: record,
			            		marker: marker
			            	});
            			}
            		});
            	}
            });
             
            //handle action button clicks              
            $('#AddToTrip-' + record.contentKey).click(function() {
                AddMarkerToTrip(marker);
                ShowDirectionsTab();
                HideBubbles();
            });
            $('#SetProxCenter-' + record.contentKey).click(function() {
                addProximityLayer({ proximityType: 'Circle', latitude: marker.Lat, longitude: marker.Long, address: record.markerAddress });
                HideBubbles();
            });
            $('#RemoveMarker-' + record.contentKey).click(function() {
                RemoveMarker(marker);
                HideBubbles();
            });
            $('#SetVerifiedLocation-' + record.contentKey).click(function() {
            	HideBubbles();
            	
            	//store the current marker color so we can set it back later
            	var currentMarkerColor = (marker.brush && marker.brush.color) ? marker.brush.color : '#000000';
            	
            	//make the marker draggable and listen for drag events
				marker.set({draggable: true, brush: 'yellow'});
				marker.addListener('dragend', function (evt) {
					var mapDragType = evt.dataTransfer.getData("application/map-drag-type"); 
					var marker = evt.dataTransfer.getData("application/map-drag-object");
					var offset = evt.dataTransfer.getData("application/map-drag-object-offset");
					
					//reset the marker to non-draggable
					marker.set({
						draggable: false,
						brush: currentMarkerColor
					});
					
					//get coordinates where the marker was dropped
					var dropCoordinate = map.pixelToGeo(evt.displayX - offset.x + marker.anchor.x, evt.displayY - offset.y + marker.anchor.y);
					
					//send request to update the verified lat/long for this record
					var requestData = {
						action			: 'set_verified_location',
						baseObjectId	: marker.record.plottedQuery.data('BaseObjectId'),
						recordId		: marker.record.record.Id,
						latitude		: dropCoordinate.latitude,
						longitude		: dropCoordinate.longitude
					};
					$.getJSON("/apex/MATooltipAJAXResources", requestData, function(response)
				    { 
				        if(response.success)
				        {
				        	//update the verified latitude and longitude on this marker
				        	marker.Lat = marker.record.markerLatitude = marker.record.verifiedLatitude = dropCoordinate.latitude;
				        	marker.Long = marker.record.markerLongitude = marker.record.verifiedLongitude = dropCoordinate.longitude;  
				        }
				        else
				        {
				        	//show error and move marker back to where it was
				        	growlError($('#growl-wrapper'), 'Unable to set verified location', 3000);
				        	marker.set('coordinate', new nokia.maps.geo.Coordinate(marker.Lat, marker.Long));
				        }
				    })
				    .error(function() { 
				    	growlError($('#growl-wrapper'), 'Unable to set verified location', 3000);
				    	marker.set('coordinate', new nokia.maps.geo.Coordinate(marker.Lat, marker.Long)); 
				    });
				});
            });
            $('#AddToCampaign-' + record.contentKey).click(function() {
                AddVisibleToCampaign(record.record.Id);
                HideBubbles();
            });
            $('#ChangeOwner-' + record.contentKey).click(function() {
                ChangeOwner([record.record.Id]);
                HideBubbles();
            });
        }
        
        function extractTooltipValue(tooltipMetadata, record)
        {
        	if (tooltipMetadata && record)
        	{
	        	//figure out the tooltip value
				var tooltipValue = tooltipMetadata.Accessible ? '' : 'Insufficient Privileges';
	           	var tooltipRefId;
	       		if (tooltipMetadata.Accessible && tooltipMetadata.FieldName != null)
	   			{
	   				//is this a reference field?
		           	if (tooltipMetadata.FieldName.indexOf(".") > -1)
		           	{ 
		               	//yes, so split on the dot and make the value a link
		               	if (record.record[tooltipMetadata.FieldName.split(".")[0]] != null)
		               	{
							var fieldParts = tooltipMetadata.FieldName.split(".");
		                   
		                   	tooltipValue = record.record[tooltipMetadata.FieldName.split(".")[0]][tooltipMetadata.FieldName.split(".")[1]];
		                   	tooltipRefId = record.record[tooltipMetadata.RefFieldName.split(".")[0]][tooltipMetadata.RefFieldName.split(".")[1]];   
		                   	tooltipValue = '<a target="_blank" href="/' + tooltipRefId + '">' + tooltipValue + '</a>';
		               	}
		           	}
		           	else
		           	{
		           		//no, so just get the data
		               	tooltipValue = record.record[tooltipMetadata.FieldName];
		           	}
		           
		            //if we have a tooltip value, format it
		           	if (tooltipValue != "")
		           	{
		               	tooltipValue = FormatsObjectValue(tooltipValue, tooltipMetadata.DisplayType, tooltipRefId);
		           	}
		       	}
		       	
		       	//return the value
		       	return tooltipValue;
		    }
		    
		    //just return blank if we weren't passed the proper data
		    return '';
        }
        
        //this is metadata that will be used to render and edit tooltips properly
        var displayTypeMetadata = {
        	'STRING': {
        		editType	: 'string',
        		renderType	: 'text'
        	},
        	'EMAIL': {
        		editType	: 'string',
        		renderType	: 'text'
        	},
        	'PHONE': {
        		editType	: 'string',
        		renderType	: 'text'
        	},
        	'URL': {
        		editType	: 'string',
        		renderType	: 'html'
        	},
        	'DOUBLE': {
        		editType	: 'number',
        		renderType	: 'text'
        	},
        	'CURRENCY': {
        		editType	: 'number',
        		renderType	: 'text'
        	},
        	'TEXTAREA': {
        		editType	: 'textarea',
        		renderType	: 'text'
        	},
        	'PICKLIST': {
        		editType	: 'picklist',
        		renderType	: 'text'
        	},
        	'MULTIPICKLIST': {
        		editType	: 'multipicklist',
        		renderType	: 'text'
        	},
        	'BOOLEAN': {
        		editType	: 'boolean',
        		renderType	: 'text'
        	},
        	'REFERENCE': {
        		editType	: 'reference',
        		renderType	: 'html'
        	},
        	'DATE': {
        		editType	: 'date',
        		renderType	: 'text'
        	},
        	'DATETIME': {
        		editType	: 'date',
        		renderType	: 'text'
        	}
        };
	</script>
</apex:component>